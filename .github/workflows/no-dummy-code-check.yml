name: Production Code Quality Check

on:
  push:
    branches: [ main, develop, production ]
  pull_request:
    branches: [ main, develop, production ]

jobs:
  check-no-dummy-code:
    name: Verify No Dummy/Mock Code in Production
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Check for Mock Classes
      run: |
        echo "üîç Checking for Mock/Dummy/Fake classes..."
        if grep -r "class Mock\|class Dummy\|class Fake\|class Test[^i]" src/ --include="*.py" | grep -v "# Abstract\|# Interface\|# Base class"; then
          echo "‚ùå ERROR: Found mock/dummy classes in production code!"
          exit 1
        fi
        echo "‚úÖ No mock classes found"
    
    - name: Check for Mock Return Values
      run: |
        echo "üîç Checking for functions returning mock data..."
        if grep -r "return.*mock_\|return.*dummy_\|return.*fake_\|return.*test_data" src/ --include="*.py" | grep -v "# Fallback\|# Development only"; then
          echo "‚ùå ERROR: Found functions returning mock data!"
          exit 1
        fi
        echo "‚úÖ No mock return values found"
    
    - name: Check for Unimplemented Functions
      run: |
        echo "üîç Checking for placeholder implementations..."
        # Check for suspicious return True/None with placeholder comments
        if grep -r "return True.*# [Pp]laceholder\|return None.*# [Pp]laceholder" src/ --include="*.py"; then
          echo "‚ùå ERROR: Found placeholder implementations!"
          exit 1
        fi
        echo "‚úÖ No placeholder implementations found"
    
    - name: Check for NotImplementedError in Non-Abstract Methods
      run: |
        echo "üîç Checking for NotImplementedError in concrete classes..."
        # This is more complex - we check for NotImplementedError not in abstract base classes
        python3 << 'EOF'
import os
import ast
import sys

def is_abstract_method(node, class_node):
    """Check if a method is abstract or in an abstract class."""
    # Check for @abstractmethod decorator
    for decorator in node.decorator_list:
        if isinstance(decorator, ast.Name) and decorator.id == 'abstractmethod':
            return True
    
    # Check if class name suggests it's abstract/interface
    class_name = class_node.name if class_node else ""
    abstract_patterns = ['Abstract', 'Base', 'Interface', 'Protocol', 'Backend']
    for pattern in abstract_patterns:
        if pattern in class_name:
            return True
    
    return False

def check_file(filepath):
    """Check a Python file for non-abstract NotImplementedError."""
    with open(filepath, 'r', encoding='utf-8') as f:
        try:
            tree = ast.parse(f.read())
        except:
            return []
    
    issues = []
    
    for node in ast.walk(tree):
        if isinstance(node, ast.ClassDef):
            for item in node.body:
                if isinstance(item, ast.FunctionDef):
                    # Check for NotImplementedError in the function
                    for stmt in ast.walk(item):
                        if isinstance(stmt, ast.Raise):
                            if isinstance(stmt.exc, ast.Name) and stmt.exc.id == 'NotImplementedError':
                                if not is_abstract_method(item, node):
                                    issues.append(f"{filepath}:{item.lineno}: {node.name}.{item.name}")
                            elif isinstance(stmt.exc, ast.Call):
                                if isinstance(stmt.exc.func, ast.Name) and stmt.exc.func.id == 'NotImplementedError':
                                    if not is_abstract_method(item, node):
                                        issues.append(f"{filepath}:{item.lineno}: {node.name}.{item.name}")
    
    return issues

# Check all Python files
all_issues = []
for root, dirs, files in os.walk('src'):
    for file in files:
        if file.endswith('.py'):
            filepath = os.path.join(root, file)
            issues = check_file(filepath)
            all_issues.extend(issues)

if all_issues:
    print("‚ùå Found NotImplementedError in non-abstract methods:")
    for issue in all_issues:
        print(f"  - {issue}")
    sys.exit(1)
else:
    print("‚úÖ No improper NotImplementedError usage found")
EOF
    
    - name: Check for Development-Only Files
      run: |
        echo "üîç Checking for example/test files in src/..."
        if find src/ -type f -name "*example*.py" -o -name "*dummy*.py" -o -name "*mock*.py" -o -name "*test*.py" | grep -v "__pycache__"; then
          echo "‚ö†Ô∏è WARNING: Found potential development-only files in src/"
          echo "Please verify these are production-ready or remove them"
        fi
        echo "‚úÖ File naming check complete"
    
    - name: Summary
      run: |
        echo "="
        echo "üéØ Production Code Quality Check Complete!"
        echo "All critical checks passed. Your code is production-ready!"
        echo "="