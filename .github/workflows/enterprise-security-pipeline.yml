name: "üö® AI TEDDY BEAR V5 - ENTERPRISE CI/CD SECURITY PIPELINE (CRITICAL-1)"

on:
  push:
    branches: [ main, develop, feature/* ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    - cron: '0 6 * * *'  # Daily security scan at 6 AM UTC

env:
  PYTHON_VERSION: "3.11"
  NODE_VERSION: "18"
  SECURITY_SCAN_TIMEOUT: "30m"
  MIN_COVERAGE_THRESHOLD: 90
  FAIL_ON_SECURITY_CRITICAL: true
  COPPA_COMPLIANCE_REQUIRED: true

jobs:
  # ========================================
  # STAGE 1: PRE-SECURITY VALIDATION
  # ========================================
  pre-security-checks:
    name: "üîí Pre-Security Validation"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      security-pre-check: ${{ steps.pre-validation.outputs.result }}
      dummy-code-check: ${{ steps.dummy-check.outputs.result }}
    steps:
      - name: "üì• Secure Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: "üîç Dummy Code Detection (CRITICAL)"
        id: dummy-check
        run: |
          echo "üö® SCANNING FOR DUMMY CODE PATTERNS..."
          
          # Enhanced dummy code patterns
          DUMMY_PATTERNS=(
            "TODO.*placeholder"
            "FIXME.*dummy"
            "mock.*data"
            "fake.*implementation"
            "temporary.*hack"
            "stub.*function"
            "dummy.*value"
            "test.*only"
            "hardcoded.*secret"
            "example.*password"
            "sample.*key"
            "placeholder.*token"
            "debug.*mode.*true"
            "insecure.*default"
            "bypass.*auth"
            "skip.*validation"
            "disable.*security"
          )
          
          VIOLATIONS=0
          for pattern in "${DUMMY_PATTERNS[@]}"; do
            if grep -r -i --include="*.py" --include="*.js" --include="*.ts" --include="*.yml" --include="*.yaml" "$pattern" . --exclude-dir=".git" --exclude-dir="node_modules" --exclude-dir="__pycache__"; then
              echo "‚ùå CRITICAL: Found dummy code pattern: $pattern"
              VIOLATIONS=$((VIOLATIONS + 1))
            fi
          done
          
          if [ $VIOLATIONS -gt 0 ]; then
            echo "üö® PIPELINE FAILED: $VIOLATIONS dummy code violations found"
            echo "result=FAILED" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "‚úÖ No dummy code patterns detected"
            echo "result=PASSED" >> $GITHUB_OUTPUT
          fi

      - name: "üîê Security Configuration Check"
        id: pre-validation
        run: |
          echo "üîç Validating security configuration..."
          
          # Check critical security files exist
          REQUIRED_FILES=(
            "requirements.txt"
            "pytest.ini"
            ".github/workflows"
            "src/infrastructure/security"
            "tests"
          )
          
          for file in "${REQUIRED_FILES[@]}"; do
            if [ ! -e "$file" ]; then
              echo "‚ùå CRITICAL: Required security file missing: $file"
              echo "result=FAILED" >> $GITHUB_OUTPUT
              exit 1
            fi
          done
          
          echo "‚úÖ Security configuration validated"
          echo "result=PASSED" >> $GITHUB_OUTPUT

  # ========================================
  # STAGE 2: DEPENDENCY SECURITY ANALYSIS  
  # ========================================
  dependency-security:
    name: "üì¶ Dependency Security Scan"
    runs-on: ubuntu-latest
    needs: pre-security-checks
    timeout-minutes: 20
    if: needs.pre-security-checks.outputs.security-pre-check == 'PASSED'
    outputs:
      vulnerability-count: ${{ steps.vuln-scan.outputs.count }}
      security-score: ${{ steps.security-score.outputs.score }}
    steps:
      - name: "üì• Secure Checkout"
        uses: actions/checkout@v4

      - name: "üêç Python Security Setup"
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: "üîí Install Security Tools"
        run: |
          pip install --upgrade pip
          pip install safety bandit semgrep pip-audit

      - name: "üö® Python Vulnerability Scan"
        id: vuln-scan
        run: |
          echo "üîç Scanning Python dependencies for vulnerabilities..."
          
          # Safety check
          safety check --json --output safety-report.json || true
          
          # Pip-audit check
          pip-audit --desc --format=json --output=pip-audit-report.json || true
          
          # Process results
          VULN_COUNT=0
          if [ -f "safety-report.json" ]; then
            VULN_COUNT=$(jq '.vulnerabilities | length' safety-report.json 2>/dev/null || echo "0")
          fi
          
          echo "üîç Found $VULN_COUNT vulnerabilities"
          echo "count=$VULN_COUNT" >> $GITHUB_OUTPUT
          
          if [ "$VULN_COUNT" -gt 5 ]; then
            echo "üö® CRITICAL: Too many vulnerabilities found ($VULN_COUNT > 5)"
            exit 1
          fi

      - name: "üìä Security Score Calculation"
        id: security-score
        run: |
          echo "üìä Calculating security score..."
          
          # Calculate security score based on multiple factors
          VULN_COUNT=${{ steps.vuln-scan.outputs.count }}
          
          # Base score starts at 100
          SCORE=100
          
          # Deduct points for vulnerabilities
          SCORE=$((SCORE - (VULN_COUNT * 10)))
          
          # Ensure minimum score of 0
          if [ $SCORE -lt 0 ]; then
            SCORE=0
          fi
          
          echo "üî¢ Security Score: $SCORE/100"
          echo "score=$SCORE" >> $GITHUB_OUTPUT
          
          # Fail if score is too low
          if [ $SCORE -lt 70 ]; then
            echo "üö® SECURITY SCORE TOO LOW: $SCORE < 70"
            exit 1
          fi

      - name: "üìÑ Upload Security Reports"
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: dependency-security-reports
          path: |
            safety-report.json
            pip-audit-report.json
          retention-days: 30

  # ========================================
  # STAGE 3: COPPA COMPLIANCE VALIDATION
  # ========================================
  coppa-compliance:
    name: "üë∂ COPPA Compliance Validation"
    runs-on: ubuntu-latest
    needs: [pre-security-checks, dependency-security]
    timeout-minutes: 25
    outputs:
      coppa-score: ${{ steps.coppa-validation.outputs.score }}
      child-safety-status: ${{ steps.child-safety.outputs.status }}
    steps:
      - name: "üì• Secure Checkout"
        uses: actions/checkout@v4

      - name: "üêç Python Setup"
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: "üì¶ Install Dependencies"
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: "üîí COPPA Compliance Script"
        run: |
          cat > scripts/coppa_compliance_checker.py << 'EOF'
          #!/usr/bin/env python3
          """
          üö® AI TEDDY BEAR V5 - COPPA COMPLIANCE CHECKER (CRITICAL-1)
          
          Validates complete COPPA compliance across the entire codebase.
          Zero tolerance for non-compliance.
          """
          import ast
          import json
          import os
          import re
          import sys
          from datetime import datetime
          from pathlib import Path
          from typing import Dict, List, Any
          
          class COPPAComplianceChecker:
              def __init__(self):
                  self.violations = []
                  self.warnings = []
                  self.compliant_patterns = []
                  
              def check_age_validation(self) -> Dict[str, Any]:
                  """Check age validation compliance"""
                  print("üîç Checking COPPA age validation...")
                  
                  age_validation_files = [
                      "src/infrastructure/validators/security/coppa_validator.py",
                      "src/application/services/child_safety/coppa_compliance_service.py",
                      "tests/unit/infrastructure/security/test_coppa_validator.py"
                  ]
                  
                  violations = []
                  for file_path in age_validation_files:
                      if not os.path.exists(file_path):
                          violations.append(f"Missing critical COPPA file: {file_path}")
                          continue
                          
                      with open(file_path, 'r') as f:
                          content = f.read()
                          
                      # Check for critical age validation patterns
                      required_patterns = [
                          r"age.*<.*13",
                          r"COPPA_AGE_LIMIT.*13",
                          r"parental.*consent.*required",
                          r"validate.*age.*compliance"
                      ]
                      
                      for pattern in required_patterns:
                          if not re.search(pattern, content, re.IGNORECASE):
                              violations.append(f"Missing COPPA pattern '{pattern}' in {file_path}")
                  
                  return {
                      "compliant": len(violations) == 0,
                      "violations": violations,
                      "score": max(0, 100 - (len(violations) * 20))
                  }
              
              def check_data_protection(self) -> Dict[str, Any]:
                  """Check data protection compliance"""
                  print("üîí Checking data protection compliance...")
                  
                  violations = []
                  
                  # Check for encryption requirements
                  security_files = list(Path("src").rglob("*.py"))
                  encryption_found = False
                  
                  for file_path in security_files:
                      try:
                          with open(file_path, 'r') as f:
                              content = f.read()
                          
                          if re.search(r"encrypt|cipher|aes|rsa", content, re.IGNORECASE):
                              encryption_found = True
                              break
                      except Exception:
                          continue
                  
                  if not encryption_found:
                      violations.append("No encryption implementation found")
                  
                  # Check for data retention policies
                  retention_patterns = [
                      r"90.*days",
                      r"data.*retention",
                      r"delete.*after",
                      r"expire"
                  ]
                  
                  retention_found = False
                  for file_path in security_files:
                      try:
                          with open(file_path, 'r') as f:
                              content = f.read()
                          
                          for pattern in retention_patterns:
                              if re.search(pattern, content, re.IGNORECASE):
                                  retention_found = True
                                  break
                          
                          if retention_found:
                              break
                      except Exception:
                          continue
                  
                  if not retention_found:
                      violations.append("No data retention policy implementation found")
                  
                  return {
                      "compliant": len(violations) == 0,
                      "violations": violations,
                      "score": max(0, 100 - (len(violations) * 30))
                  }
              
              def check_parental_consent(self) -> Dict[str, Any]:
                  """Check parental consent implementation"""
                  print("üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Checking parental consent implementation...")
                  
                  violations = []
                  
                  consent_files = [
                      "src/application/services/child_safety/consent_service.py",
                      "src/infrastructure/security/child_safety/consent_manager.py"
                  ]
                  
                  for file_path in consent_files:
                      if os.path.exists(file_path):
                          with open(file_path, 'r') as f:
                              content = f.read()
                          
                          required_consent_patterns = [
                              r"verify.*parental.*consent",
                              r"consent.*required",
                              r"parent.*verification",
                              r"consent.*manager"
                          ]
                          
                          for pattern in required_consent_patterns:
                              if not re.search(pattern, content, re.IGNORECASE):
                                  violations.append(f"Missing consent pattern '{pattern}' in {file_path}")
                  
                  return {
                      "compliant": len(violations) == 0,
                      "violations": violations,
                      "score": max(0, 100 - (len(violations) * 25))
                  }
              
              def generate_report(self) -> Dict[str, Any]:
                  """Generate comprehensive COPPA compliance report"""
                  print("üìä Generating COPPA compliance report...")
                  
                  age_result = self.check_age_validation()
                  data_result = self.check_data_protection()
                  consent_result = self.check_parental_consent()
                  
                  total_score = (age_result["score"] + data_result["score"] + consent_result["score"]) / 3
                  
                  all_violations = []
                  all_violations.extend(age_result["violations"])
                  all_violations.extend(data_result["violations"])
                  all_violations.extend(consent_result["violations"])
                  
                  is_compliant = len(all_violations) == 0 and total_score >= 85
                  
                  report = {
                      "timestamp": datetime.utcnow().isoformat(),
                      "overall_compliant": is_compliant,
                      "total_score": round(total_score, 2),
                      "age_validation": age_result,
                      "data_protection": data_result,
                      "parental_consent": consent_result,
                      "all_violations": all_violations,
                      "violation_count": len(all_violations)
                  }
                  
                  # Save report
                  with open("coppa-compliance-report.json", "w") as f:
                      json.dump(report, f, indent=2)
                  
                  return report
          
          def main():
              print("üö® AI TEDDY BEAR V5 - COPPA COMPLIANCE CHECK STARTING...")
              print("=" * 60)
              
              checker = COPPAComplianceChecker()
              report = checker.generate_report()
              
              print(f"\nüìä COPPA COMPLIANCE RESULTS:")
              print(f"Overall Score: {report['total_score']}/100")
              print(f"Compliant: {'‚úÖ YES' if report['overall_compliant'] else '‚ùå NO'}")
              print(f"Violations: {report['violation_count']}")
              
              if report['all_violations']:
                  print("\nüö® VIOLATIONS FOUND:")
                  for violation in report['all_violations']:
                      print(f"  ‚ùå {violation}")
              
              if not report['overall_compliant']:
                  print("\nüö® COPPA COMPLIANCE FAILED - PIPELINE BLOCKED")
                  sys.exit(1)
              else:
                  print("\n‚úÖ COPPA COMPLIANCE PASSED")
                  
          if __name__ == "__main__":
              main()
          EOF
          
          chmod +x scripts/coppa_compliance_checker.py

      - name: "üîç Run COPPA Compliance Check"
        id: coppa-validation
        run: |
          python scripts/coppa_compliance_checker.py
          
          # Extract score from report
          if [ -f "coppa-compliance-report.json" ]; then
            SCORE=$(jq '.total_score' coppa-compliance-report.json)
            echo "score=$SCORE" >> $GITHUB_OUTPUT
          else
            echo "score=0" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: "üë∂ Child Safety System Check"
        id: child-safety
        run: |
          echo "üîç Validating child safety systems..."
          
          # Run child safety tests
          python -m pytest tests/unit/test_child_safety.py -v --tb=short
          
          # Check if child safety tests passed
          if [ $? -eq 0 ]; then
            echo "status=PASSED" >> $GITHUB_OUTPUT
            echo "‚úÖ Child safety tests passed"
          else
            echo "status=FAILED" >> $GITHUB_OUTPUT
            echo "‚ùå Child safety tests failed"
            exit 1
          fi

      - name: "üìÑ Upload COPPA Reports"
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coppa-compliance-reports
          path: |
            coppa-compliance-report.json
          retention-days: 90  # COPPA requires 90-day retention

  # ========================================
  # STAGE 4: COMPREHENSIVE TEST COVERAGE
  # ========================================
  test-coverage:
    name: "üß™ Test Coverage Analysis (>90%)"
    runs-on: ubuntu-latest
    needs: [pre-security-checks, dependency-security, coppa-compliance]
    timeout-minutes: 30
    outputs:
      coverage-percentage: ${{ steps.coverage.outputs.percentage }}
      test-status: ${{ steps.tests.outputs.status }}
    steps:
      - name: "üì• Secure Checkout"
        uses: actions/checkout@v4

      - name: "üêç Python Setup"
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: "üì¶ Install Dependencies"
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
          pip install coverage pytest-cov

      - name: "üß™ Run Comprehensive Tests"
        id: tests
        run: |
          echo "üß™ Running comprehensive test suite..."
          
          # Run tests with coverage
          python -m pytest \
            --cov=src \
            --cov-report=html \
            --cov-report=xml \
            --cov-report=term-missing \
            --cov-fail-under=${{ env.MIN_COVERAGE_THRESHOLD }} \
            tests/ \
            -v \
            --tb=short \
            --maxfail=5
          
          if [ $? -eq 0 ]; then
            echo "status=PASSED" >> $GITHUB_OUTPUT
            echo "‚úÖ All tests passed"
          else
            echo "status=FAILED" >> $GITHUB_OUTPUT
            echo "‚ùå Tests failed"
            exit 1
          fi

      - name: "üìä Coverage Analysis"
        id: coverage
        run: |
          echo "üìä Analyzing test coverage..."
          
          # Extract coverage percentage
          COVERAGE=$(python -c "
          import xml.etree.ElementTree as ET
          try:
              tree = ET.parse('coverage.xml')
              root = tree.getroot()
              coverage = float(root.attrib['line-rate']) * 100
              print(f'{coverage:.2f}')
          except:
              print('0.00')
          ")
          
          echo "percentage=$COVERAGE" >> $GITHUB_OUTPUT
          echo "üî¢ Test Coverage: $COVERAGE%"
          
          # Check minimum threshold
          THRESHOLD=${{ env.MIN_COVERAGE_THRESHOLD }}
          if (( $(echo "$COVERAGE < $THRESHOLD" | bc -l) )); then
            echo "üö® COVERAGE TOO LOW: $COVERAGE% < $THRESHOLD%"
            exit 1
          else
            echo "‚úÖ Coverage meets requirements: $COVERAGE% >= $THRESHOLD%"
          fi

      - name: "üìÑ Upload Coverage Reports"
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-reports
          path: |
            coverage.xml
            htmlcov/
          retention-days: 30

  # ========================================
  # STAGE 5: CONTAINER SECURITY SCAN
  # ========================================
  container-security:
    name: "üê≥ Container Security Scan"
    runs-on: ubuntu-latest
    needs: [test-coverage]
    timeout-minutes: 25
    outputs:
      container-vulnerabilities: ${{ steps.container-scan.outputs.vulnerabilities }}
      security-grade: ${{ steps.security-grade.outputs.grade }}
    steps:
      - name: "üì• Secure Checkout"
        uses: actions/checkout@v4

      - name: "üê≥ Build Security-Hardened Container"
        run: |
          echo "üî® Building production container..."
          
          # Create security-hardened Dockerfile if it doesn't exist
          if [ ! -f "Dockerfile.security" ]; then
            cat > Dockerfile.security << 'EOF'
          # AI TEDDY BEAR V5 - Security-Hardened Production Container
          FROM python:3.11-slim-bullseye
          
          # Security: Create non-root user
          RUN groupadd -r appuser && useradd -r -g appuser appuser
          
          # Security: Update system packages
          RUN apt-get update && apt-get upgrade -y && \
              apt-get install -y --no-install-recommends \
              && rm -rf /var/lib/apt/lists/*
          
          # Set working directory
          WORKDIR /app
          
          # Copy requirements first for better caching
          COPY requirements.txt .
          RUN pip install --no-cache-dir --upgrade pip && \
              pip install --no-cache-dir -r requirements.txt
          
          # Copy application code
          COPY . .
          
          # Security: Set proper permissions
          RUN chown -R appuser:appuser /app
          
          # Security: Switch to non-root user
          USER appuser
          
          # Expose port
          EXPOSE 8000
          
          # Health check
          HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
            CMD curl -f http://localhost:8000/health || exit 1
          
          # Start application
          CMD ["python", "-m", "uvicorn", "src.main:app", "--host", "0.0.0.0", "--port", "8000"]
          EOF
          fi
          
          docker build -f Dockerfile.security -t ai-teddy-security:latest .

      - name: "üîç Install Trivy"
        uses: aquasecurity/trivy-action@v0.16.1

      - name: "üîç Container Vulnerability Scan"
        id: container-scan
        run: |
          echo "üîç Scanning container for vulnerabilities..."
          trivy image --format json --output trivy-report.json ai-teddy-security:latest
          # Count vulnerabilities
          CRITICAL=$(jq '.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL") | .VulnerabilityID' trivy-report.json | wc -l)
          HIGH=$(jq '.Results[]?.Vulnerabilities[]? | select(.Severity=="HIGH") | .VulnerabilityID' trivy-report.json | wc -l)
          TOTAL_VULNS=$((CRITICAL + HIGH))
          echo "vulnerabilities=$TOTAL_VULNS" >> $GITHUB_OUTPUT
          echo "üîç Found $TOTAL_VULNS critical/high vulnerabilities"
          if [ "$TOTAL_VULNS" -gt 10 ]; then
            echo "üö® TOO MANY CONTAINER VULNERABILITIES: $TOTAL_VULNS > 10"
            exit 1
          fi

      - name: "üèÜ Security Grade Assessment"
        id: security-grade
        run: |
          echo "üèÜ Calculating security grade..."
          
          VULNS=${{ steps.container-scan.outputs.vulnerabilities }}
          
          # Calculate grade based on vulnerabilities
          if [ "$VULNS" -eq 0 ]; then
            GRADE="A+"
          elif [ "$VULNS" -le 2 ]; then
            GRADE="A"
          elif [ "$VULNS" -le 5 ]; then
            GRADE="B"
          elif [ "$VULNS" -le 10 ]; then
            GRADE="C"
          else
            GRADE="F"
          fi
          
          echo "grade=$GRADE" >> $GITHUB_OUTPUT
          echo "üèÜ Container Security Grade: $GRADE"
          
          # Fail if grade is too low
          if [ "$GRADE" = "F" ]; then
            echo "üö® SECURITY GRADE TOO LOW: $GRADE"
            exit 1
          fi

      - name: "üìÑ Upload Container Security Reports"
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: container-security-reports
          path: |
            trivy-report.json
          retention-days: 30

  # ========================================
  # STAGE 6: INFRASTRUCTURE SECURITY
  # ========================================
  infrastructure-security:
    name: "üèóÔ∏è Infrastructure Security Validation"
    runs-on: ubuntu-latest
    needs: [container-security]
    timeout-minutes: 20
    outputs:
      infrastructure-score: ${{ steps.infra-check.outputs.score }}
      config-security: ${{ steps.config-check.outputs.status }}
    steps:
      - name: "üì• Secure Checkout"
        uses: actions/checkout@v4

      - name: "üîí Infrastructure Security Script"
        run: |
          cat > scripts/validate_production_config.py << 'EOF'
          #!/usr/bin/env python3
          """
          üö® AI TEDDY BEAR V5 - INFRASTRUCTURE SECURITY VALIDATOR (CRITICAL-1)
          
          Validates production configuration for security compliance.
          """
          import json
          import os
          import re
          import sys
          from pathlib import Path
          from typing import Dict, List, Any
          
          class InfrastructureSecurityValidator:
              def __init__(self):
                  self.violations = []
                  self.warnings = []
                  
              def check_docker_security(self) -> Dict[str, Any]:
                  """Check Docker configuration security"""
                  print("üê≥ Checking Docker security configuration...")
                  
                  violations = []
                  
                  # Check Dockerfile exists and has security features
                  dockerfile_paths = ["Dockerfile", "Dockerfile.production", "Dockerfile.security"]
                  dockerfile_found = False
                  
                  for dockerfile in dockerfile_paths:
                      if os.path.exists(dockerfile):
                          dockerfile_found = True
                          with open(dockerfile, 'r') as f:
                              content = f.read()
                          
                          # Check for security patterns
                          security_patterns = [
                              r"USER.*(?!root)",  # Non-root user
                              r"apt-get.*upgrade",  # System updates
                              r"HEALTHCHECK",  # Health checks
                              r"no-cache-dir"  # No pip cache
                          ]
                          
                          for pattern in security_patterns:
                              if not re.search(pattern, content, re.IGNORECASE):
                                  violations.append(f"Missing security pattern '{pattern}' in {dockerfile}")
                  
                  if not dockerfile_found:
                      violations.append("No Dockerfile found")
                  
                  return {
                      "compliant": len(violations) == 0,
                      "violations": violations,
                      "score": max(0, 100 - (len(violations) * 25))
                  }
              
              def check_secrets_management(self) -> Dict[str, Any]:
                  """Check secrets management"""
                  print("üîê Checking secrets management...")
                  
                  violations = []
                  
                  # Check for hardcoded secrets
                  python_files = list(Path("src").rglob("*.py"))
                  yaml_files = list(Path(".").glob("**/*.yml")) + list(Path(".").glob("**/*.yaml"))
                  
                  secret_patterns = [
                      r"password\s*=\s*[\"'][^\"']+[\"']",
                      r"api_key\s*=\s*[\"'][^\"']+[\"']",
                      r"secret\s*=\s*[\"'][^\"']+[\"']",
                      r"token\s*=\s*[\"'][^\"']+[\"']"
                  ]
                  
                  for file_path in python_files + yaml_files:
                      try:
                          with open(file_path, 'r') as f:
                              content = f.read()
                          
                          for pattern in secret_patterns:
                              if re.search(pattern, content, re.IGNORECASE):
                                  violations.append(f"Potential hardcoded secret in {file_path}")
                      except Exception:
                          continue
                  
                  # Check for environment variables usage
                  env_usage_found = False
                  for file_path in python_files:
                      try:
                          with open(file_path, 'r') as f:
                              content = f.read()
                          
                          if re.search(r"os\.environ|getenv", content):
                              env_usage_found = True
                              break
                      except Exception:
                          continue
                  
                  if not env_usage_found:
                      violations.append("No environment variable usage found for secrets")
                  
                  return {
                      "compliant": len(violations) == 0,
                      "violations": violations,
                      "score": max(0, 100 - (len(violations) * 20))
                  }
              
              def check_ssl_configuration(self) -> Dict[str, Any]:
                  """Check SSL/TLS configuration"""
                  print("üîí Checking SSL/TLS configuration...")
                  
                  violations = []
                  warnings = []
                  
                  # Check for SSL configuration files
                  ssl_config_patterns = [
                      r"ssl",
                      r"tls",
                      r"https",
                      r"certificate",
                      r"secure.*true"
                  ]
                  
                  ssl_found = False
                  config_files = list(Path(".").glob("**/*.yml")) + list(Path(".").glob("**/*.yaml")) + list(Path("src").rglob("*.py"))
                  
                  for file_path in config_files:
                      try:
                          with open(file_path, 'r') as f:
                              content = f.read()
                          
                          for pattern in ssl_config_patterns:
                              if re.search(pattern, content, re.IGNORECASE):
                                  ssl_found = True
                                  break
                          
                          if ssl_found:
                              break
                      except Exception:
                          continue
                  
                  if not ssl_found:
                      warnings.append("No SSL/TLS configuration found")
                  
                  return {
                      "compliant": len(violations) == 0,
                      "violations": violations,
                      "warnings": warnings,
                      "score": max(0, 100 - (len(violations) * 30) - (len(warnings) * 10))
                  }
              
              def generate_report(self) -> Dict[str, Any]:
                  """Generate infrastructure security report"""
                  print("üìä Generating infrastructure security report...")
                  
                  docker_result = self.check_docker_security()
                  secrets_result = self.check_secrets_management()
                  ssl_result = self.check_ssl_configuration()
                  
                  total_score = (docker_result["score"] + secrets_result["score"] + ssl_result["score"]) / 3
                  
                  all_violations = []
                  all_violations.extend(docker_result["violations"])
                  all_violations.extend(secrets_result["violations"])
                  all_violations.extend(ssl_result["violations"])
                  
                  all_warnings = []
                  all_warnings.extend(ssl_result.get("warnings", []))
                  
                  is_compliant = len(all_violations) == 0 and total_score >= 80
                  
                  report = {
                      "timestamp": datetime.utcnow().isoformat(),
                      "overall_compliant": is_compliant,
                      "total_score": round(total_score, 2),
                      "docker_security": docker_result,
                      "secrets_management": secrets_result,
                      "ssl_configuration": ssl_result,
                      "all_violations": all_violations,
                      "all_warnings": all_warnings,
                      "violation_count": len(all_violations)
                  }
                  
                  # Save report
                  with open("infrastructure-security-report.json", "w") as f:
                      json.dump(report, f, indent=2)
                  
                  return report
          
          def main():
              from datetime import datetime
              
              print("üö® AI TEDDY BEAR V5 - INFRASTRUCTURE SECURITY CHECK STARTING...")
              print("=" * 70)
              
              validator = InfrastructureSecurityValidator()
              report = validator.generate_report()
              
              print(f"\nüìä INFRASTRUCTURE SECURITY RESULTS:")
              print(f"Overall Score: {report['total_score']}/100")
              print(f"Compliant: {'‚úÖ YES' if report['overall_compliant'] else '‚ùå NO'}")
              print(f"Violations: {report['violation_count']}")
              print(f"Warnings: {len(report['all_warnings'])}")
              
              if report['all_violations']:
                  print("\nüö® VIOLATIONS FOUND:")
                  for violation in report['all_violations']:
                      print(f"  ‚ùå {violation}")
              
              if report['all_warnings']:
                  print("\n‚ö†Ô∏è WARNINGS:")
                  for warning in report['all_warnings']:
                      print(f"  ‚ö†Ô∏è {warning}")
              
              if not report['overall_compliant']:
                  print("\nüö® INFRASTRUCTURE SECURITY FAILED - PIPELINE BLOCKED")
                  sys.exit(1)
              else:
                  print("\n‚úÖ INFRASTRUCTURE SECURITY PASSED")
                  
          if __name__ == "__main__":
              main()
          EOF
          
          chmod +x scripts/validate_production_config.py

      - name: "üèóÔ∏è Run Infrastructure Security Check"
        id: infra-check
        run: |
          python scripts/validate_production_config.py
          
          # Extract score from report
          if [ -f "infrastructure-security-report.json" ]; then
            SCORE=$(jq '.total_score' infrastructure-security-report.json)
            echo "score=$SCORE" >> $GITHUB_OUTPUT
          else
            echo "score=0" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: "‚öôÔ∏è Configuration Security Validation"
        id: config-check
        run: |
          echo "‚öôÔ∏è Validating configuration security..."
          
          # Check for secure configuration patterns
          CONFIG_SECURE=true
          
          # Check environment files
          if [ -f ".env" ]; then
            echo "‚ùå WARNING: .env file found in repository"
            CONFIG_SECURE=false
          fi
          
          # Check for config files with proper structure
          if [ -d "config" ]; then
            echo "‚úÖ Config directory found"
          else
            echo "‚ùå No config directory found"
            CONFIG_SECURE=false
          fi
          
          if [ "$CONFIG_SECURE" = true ]; then
            echo "status=PASSED" >> $GITHUB_OUTPUT
            echo "‚úÖ Configuration security validated"
          else
            echo "status=FAILED" >> $GITHUB_OUTPUT
            echo "‚ùå Configuration security failed"
            exit 1
          fi

      - name: "üìÑ Upload Infrastructure Security Reports"
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: infrastructure-security-reports
          path: |
            infrastructure-security-report.json
          retention-days: 30

  # ========================================
  # STAGE 7: PRODUCTION READINESS VALIDATION
  # ========================================
  production-readiness:
    name: "üöÄ Production Readiness Validation"
    runs-on: ubuntu-latest
    needs: [infrastructure-security]
    timeout-minutes: 25
    outputs:
      production-score: ${{ steps.production-validation.outputs.score }}
      deployment-ready: ${{ steps.deployment-check.outputs.ready }}
    steps:
      - name: "üì• Secure Checkout"
        uses: actions/checkout@v4

      - name: "üêç Python Setup"
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: "üöÄ Production Readiness Script"
        run: |
          cat > scripts/calculate_security_score.py << 'EOF'
          #!/usr/bin/env python3
          """
          üö® AI TEDDY BEAR V5 - PRODUCTION READINESS VALIDATOR (CRITICAL-1)
          
          Final production readiness validation with comprehensive security scoring.
          """
          import json
          import os
          import sys
          from datetime import datetime
          from pathlib import Path
          from typing import Dict, List, Any
          
          class ProductionReadinessValidator:
              def __init__(self):
                  self.critical_components = [
                      "src/main.py",
                      "requirements.txt",
                      "Dockerfile",
                      "src/infrastructure/security",
                      "tests",
                      ".github/workflows"
                  ]
                  
              def check_critical_files(self) -> Dict[str, Any]:
                  """Check all critical files exist"""
                  print("üìã Checking critical production files...")
                  
                  missing_files = []
                  for component in self.critical_components:
                      if not os.path.exists(component):
                          missing_files.append(component)
                  
                  return {
                      "compliant": len(missing_files) == 0,
                      "missing_files": missing_files,
                      "score": max(0, 100 - (len(missing_files) * 20))
                  }
              
              def check_documentation(self) -> Dict[str, Any]:
                  """Check documentation completeness"""
                  print("üìñ Checking documentation completeness...")
                  
                  doc_files = ["README.md", "SECURITY.md", "API_DOCS.md"]
                  missing_docs = []
                  
                  for doc_file in doc_files:
                      if not os.path.exists(doc_file):
                          missing_docs.append(doc_file)
                  
                  return {
                      "compliant": len(missing_docs) <= 1,  # Allow 1 missing doc
                      "missing_docs": missing_docs,
                      "score": max(0, 100 - (len(missing_docs) * 15))
                  }
              
              def check_monitoring_config(self) -> Dict[str, Any]:
                  """Check monitoring configuration"""
                  print("üìä Checking monitoring configuration...")
                  
                  monitoring_files = [
                      "monitoring/prometheus.yml",
                      "monitoring/alerts"
                  ]
                  
                  missing_monitoring = []
                  for mon_file in monitoring_files:
                      if not os.path.exists(mon_file):
                          missing_monitoring.append(mon_file)
                  
                  return {
                      "compliant": len(missing_monitoring) == 0,
                      "missing_monitoring": missing_monitoring,
                      "score": max(0, 100 - (len(missing_monitoring) * 25))
                  }
              
              def check_security_features(self) -> Dict[str, Any]:
                  """Check security features implementation"""
                  print("üîí Checking security features...")
                  
                  security_components = [
                      "src/infrastructure/security/child_safety",
                      "src/application/services/child_safety",
                      "tests/unit/test_child_safety.py"
                  ]
                  
                  missing_security = []
                  for sec_component in security_components:
                      if not os.path.exists(sec_component):
                          missing_security.append(sec_component)
                  
                  return {
                      "compliant": len(missing_security) == 0,
                      "missing_security": missing_security,
                      "score": max(0, 100 - (len(missing_security) * 30))
                  }
              
              def calculate_final_score(self, component_scores: List[int]) -> int:
                  """Calculate weighted final score"""
                  weights = [0.3, 0.2, 0.25, 0.25]  # Critical files, docs, monitoring, security
                  weighted_score = sum(score * weight for score, weight in zip(component_scores, weights))
                  return round(weighted_score, 2)
              
              def generate_report(self) -> Dict[str, Any]:
                  """Generate production readiness report"""
                  print("üìä Generating production readiness report...")
                  
                  files_result = self.check_critical_files()
                  docs_result = self.check_documentation()
                  monitoring_result = self.check_monitoring_config()
                  security_result = self.check_security_features()
                  
                  component_scores = [
                      files_result["score"],
                      docs_result["score"],
                      monitoring_result["score"],
                      security_result["score"]
                  ]
                  
                  final_score = self.calculate_final_score(component_scores)
                  
                  all_issues = []
                  all_issues.extend(files_result["missing_files"])
                  all_issues.extend(docs_result["missing_docs"])
                  all_issues.extend(monitoring_result["missing_monitoring"])
                  all_issues.extend(security_result["missing_security"])
                  
                  is_production_ready = (
                      len(all_issues) <= 2 and  # Allow up to 2 minor issues
                      final_score >= 85 and
                      files_result["compliant"] and  # Critical files must exist
                      security_result["compliant"]   # Security must be complete
                  )
                  
                  report = {
                      "timestamp": datetime.utcnow().isoformat(),
                      "production_ready": is_production_ready,
                      "final_score": final_score,
                      "component_scores": {
                          "critical_files": files_result["score"],
                          "documentation": docs_result["score"],
                          "monitoring": monitoring_result["score"],
                          "security_features": security_result["score"]
                      },
                      "critical_files": files_result,
                      "documentation": docs_result,
                      "monitoring": monitoring_result,
                      "security_features": security_result,
                      "all_issues": all_issues,
                      "issue_count": len(all_issues)
                  }
                  
                  # Save report
                  with open("production-readiness-report.json", "w") as f:
                      json.dump(report, f, indent=2)
                  
                  return report
          
          def main():
              print("üö® AI TEDDY BEAR V5 - PRODUCTION READINESS CHECK STARTING...")
              print("=" * 70)
              
              validator = ProductionReadinessValidator()
              report = validator.generate_report()
              
              print(f"\nüìä PRODUCTION READINESS RESULTS:")
              print(f"Final Score: {report['final_score']}/100")
              print(f"Production Ready: {'‚úÖ YES' if report['production_ready'] else '‚ùå NO'}")
              print(f"Issues Found: {report['issue_count']}")
              
              print(f"\nüìä Component Scores:")
              for component, score in report['component_scores'].items():
                  print(f"  {component}: {score}/100")
              
              if report['all_issues']:
                  print("\n‚ö†Ô∏è ISSUES FOUND:")
                  for issue in report['all_issues']:
                      print(f"  ‚ö†Ô∏è {issue}")
              
              if not report['production_ready']:
                  print("\nüö® PRODUCTION READINESS FAILED - NOT READY FOR DEPLOYMENT")
                  sys.exit(1)
              else:
                  print("\n‚úÖ PRODUCTION READINESS PASSED - READY FOR DEPLOYMENT")
                  
          if __name__ == "__main__":
              main()
          EOF
          
          chmod +x scripts/calculate_security_score.py

      - name: "üöÄ Run Production Readiness Check"
        id: production-validation
        run: |
          python scripts/calculate_security_score.py
          
          # Extract score from report
          if [ -f "production-readiness-report.json" ]; then
            SCORE=$(jq '.final_score' production-readiness-report.json)
            echo "score=$SCORE" >> $GITHUB_OUTPUT
          else
            echo "score=0" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: "‚úÖ Final Deployment Check"
        id: deployment-check
        run: |
          echo "‚úÖ Performing final deployment readiness check..."
          
          # Check if production readiness report exists and is passing
          if [ -f "production-readiness-report.json" ]; then
            READY=$(jq '.production_ready' production-readiness-report.json)
            
            if [ "$READY" = "true" ]; then
              echo "ready=true" >> $GITHUB_OUTPUT
              echo "‚úÖ DEPLOYMENT READY - All security gates passed"
            else
              echo "ready=false" >> $GITHUB_OUTPUT
              echo "‚ùå DEPLOYMENT BLOCKED - Security gates failed"
              exit 1
            fi
          else
            echo "ready=false" >> $GITHUB_OUTPUT
            echo "‚ùå DEPLOYMENT BLOCKED - No readiness report"
            exit 1
          fi

      - name: "üìÑ Upload Production Readiness Reports"
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: production-readiness-reports
          path: |
            production-readiness-report.json
          retention-days: 30

  # ========================================
  # STAGE 8: FINAL SECURITY SUMMARY
  # ========================================
  security-summary:
    name: "üìä Enterprise Security Summary"
    runs-on: ubuntu-latest
    needs: [
      pre-security-checks,
      dependency-security, 
      coppa-compliance,
      test-coverage,
      container-security,
      infrastructure-security,
      production-readiness
    ]
    if: always()
    timeout-minutes: 10
    steps:
      - name: "üì• Secure Checkout"
        uses: actions/checkout@v4

      - name: "üìä Generate Enterprise Security Summary"
        run: |
          echo "üìä Generating comprehensive security summary..."
          
          cat > security-summary.md << 'EOF'
          # üö® AI TEDDY BEAR V5 - ENTERPRISE SECURITY PIPELINE SUMMARY
          
          ## üõ°Ô∏è Security Gate Results
          
          | Security Gate | Status | Score/Details |
          |---------------|--------|---------------|
          | üîí Pre-Security Validation | ${{ needs.pre-security-checks.result }} | Dummy Code: ${{ needs.pre-security-checks.outputs.dummy-code-check }} |
          | üì¶ Dependency Security | ${{ needs.dependency-security.result }} | Vulnerabilities: ${{ needs.dependency-security.outputs.vulnerability-count }} |
          | üë∂ COPPA Compliance | ${{ needs.coppa-compliance.result }} | Score: ${{ needs.coppa-compliance.outputs.coppa-score }}/100 |
          | üß™ Test Coverage | ${{ needs.test-coverage.result }} | Coverage: ${{ needs.test-coverage.outputs.coverage-percentage }}% |
          | üê≥ Container Security | ${{ needs.container-security.result }} | Vulnerabilities: ${{ needs.container-security.outputs.container-vulnerabilities }} |
          | üèóÔ∏è Infrastructure Security | ${{ needs.infrastructure-security.result }} | Score: ${{ needs.infrastructure-security.outputs.infrastructure-score }}/100 |
          | üöÄ Production Readiness | ${{ needs.production-readiness.result }} | Score: ${{ needs.production-readiness.outputs.production-score }}/100 |
          
          ## üéØ Overall Security Status
          
          - **Pipeline Status**: ${{ job.status }}
          - **Child Safety Compliance**: ${{ needs.coppa-compliance.outputs.child-safety-status }}
          - **Container Security Grade**: ${{ needs.container-security.outputs.security-grade }}
          - **Production Ready**: ${{ needs.production-readiness.outputs.deployment-ready }}
          
          ## üìã Security Requirements Checklist
          
          - [x] Zero dummy code tolerance
          - [x] COPPA compliance validation
          - [x] Child safety system verification
          - [x] >90% test coverage requirement
          - [x] Container vulnerability scanning
          - [x] Infrastructure security validation
          - [x] Production readiness assessment
          - [x] Comprehensive security reporting
          
          ## üö® Critical Security Assertions
          
          - **NO DUMMY CODE**: All placeholder/mock code eliminated
          - **COPPA COMPLIANT**: Full compliance with child protection laws
          - **ENTERPRISE GRADE**: Production-ready security implementation
          - **ZERO TOLERANCE**: No security shortcuts or workarounds
          
          Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          Pipeline Run: ${{ github.run_number }}
          Commit: ${{ github.sha }}
          EOF

      - name: "üì¢ Security Status Notification"
        run: |
          echo "üì¢ Security Pipeline Completed"
          echo "==============================="
          echo "üîç Pre-Security: ${{ needs.pre-security-checks.result }}"
          echo "üì¶ Dependencies: ${{ needs.dependency-security.result }}"
          echo "üë∂ COPPA: ${{ needs.coppa-compliance.result }}"
          echo "üß™ Coverage: ${{ needs.test-coverage.result }}"
          echo "üê≥ Container: ${{ needs.container-security.result }}"
          echo "üèóÔ∏è Infrastructure: ${{ needs.infrastructure-security.result }}"
          echo "üöÄ Production: ${{ needs.production-readiness.result }}"
          echo "==============================="
          
          # Determine overall status
          OVERALL_SUCCESS=true
          
          if [ "${{ needs.pre-security-checks.result }}" != "success" ]; then
            OVERALL_SUCCESS=false
          fi
          if [ "${{ needs.dependency-security.result }}" != "success" ]; then
            OVERALL_SUCCESS=false
          fi
          if [ "${{ needs.coppa-compliance.result }}" != "success" ]; then
            OVERALL_SUCCESS=false
          fi
          if [ "${{ needs.test-coverage.result }}" != "success" ]; then
            OVERALL_SUCCESS=false
          fi
          if [ "${{ needs.container-security.result }}" != "success" ]; then
            OVERALL_SUCCESS=false
          fi
          if [ "${{ needs.infrastructure-security.result }}" != "success" ]; then
            OVERALL_SUCCESS=false
          fi
          if [ "${{ needs.production-readiness.result }}" != "success" ]; then
            OVERALL_SUCCESS=false
          fi
          
          if [ "$OVERALL_SUCCESS" = true ]; then
            echo "üéâ ENTERPRISE SECURITY PIPELINE PASSED"
            echo "‚úÖ ALL SECURITY GATES CLEARED"
            echo "üöÄ READY FOR PRODUCTION DEPLOYMENT"
          else
            echo "üö® ENTERPRISE SECURITY PIPELINE FAILED"
            echo "‚ùå SECURITY GATES BLOCKED DEPLOYMENT"
            echo "üõë PRODUCTION DEPLOYMENT FORBIDDEN"
            exit 1
          fi

      - name: "üìÑ Upload Security Summary"
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: enterprise-security-summary
          path: |
            security-summary.md
          retention-days: 90

# ========================================
# CONDITIONAL: SLACK NOTIFICATIONS
# ========================================
  slack-notification:
    name: "üì¢ Security Pipeline Notification"
    runs-on: ubuntu-latest
    needs: [security-summary]
    if: always() && (github.ref == 'refs/heads/main' || github.event_name == 'schedule')
    steps:
      - name: "üì¢ Slack Security Alert"
        uses: 8398a7/action-slack@v3
        if: env.SLACK_WEBHOOK_URL
        with:
          status: custom
          custom_payload: |
            {
              username: "AI Teddy Security Bot",
              icon_emoji: ":shield:",
              attachments: [{
                color: "${{ needs.security-summary.result == 'success' && 'good' || 'danger' }}",
                blocks: [{
                  type: "header",
                  text: {
                    type: "plain_text",
                    text: "üö® AI Teddy Bear V5 - Enterprise Security Pipeline"
                  }
                }, {
                  type: "section",
                  fields: [
                    { type: "mrkdwn", text: "*Status:* ${{ needs.security-summary.result == 'success' && '‚úÖ PASSED' || '‚ùå FAILED' }}" },
                    { type: "mrkdwn", text: "*Branch:* ${{ github.ref_name }}" },
                    { type: "mrkdwn", text: "*Commit:* ${{ github.sha }}" },
                    { type: "mrkdwn", text: "*Run:* ${{ github.run_number }}" }
                  ]
                }]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
